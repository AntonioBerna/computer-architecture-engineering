/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
module DIG_ROM_32X1_z (
    input [4:0] A,
    input sel,
    output reg [0:0] D
);
    reg [0:0] my_rom [0:29];

    always @ (*) begin
        if (~sel)
            D = 1'hz;
        else if (A > 5'h1d)
            D = 1'h0;
        else
            D = my_rom[A];
    end

    initial begin
        my_rom[0] = 1'h1;
        my_rom[1] = 1'h1;
        my_rom[2] = 1'h1;
        my_rom[3] = 1'h1;
        my_rom[4] = 1'h1;
        my_rom[5] = 1'h1;
        my_rom[6] = 1'h1;
        my_rom[7] = 1'h0;
        my_rom[8] = 1'h1;
        my_rom[9] = 1'h1;
        my_rom[10] = 1'h1;
        my_rom[11] = 1'h1;
        my_rom[12] = 1'h1;
        my_rom[13] = 1'h1;
        my_rom[14] = 1'h1;
        my_rom[15] = 1'h0;
        my_rom[16] = 1'h1;
        my_rom[17] = 1'h1;
        my_rom[18] = 1'h1;
        my_rom[19] = 1'h1;
        my_rom[20] = 1'h1;
        my_rom[21] = 1'h1;
        my_rom[22] = 1'h1;
        my_rom[23] = 1'h0;
        my_rom[24] = 1'h1;
        my_rom[25] = 1'h1;
        my_rom[26] = 1'h0;
        my_rom[27] = 1'h0;
        my_rom[28] = 1'h1;
        my_rom[29] = 1'h1;
    end
endmodule

module DIG_ROM_32X1_y_2 (
    input [4:0] A,
    input sel,
    output reg [0:0] D
);
    reg [0:0] my_rom [0:27];

    always @ (*) begin
        if (~sel)
            D = 1'hz;
        else if (A > 5'h1b)
            D = 1'h0;
        else
            D = my_rom[A];
    end

    initial begin
        my_rom[0] = 1'h0;
        my_rom[1] = 1'h0;
        my_rom[2] = 1'h0;
        my_rom[3] = 1'h0;
        my_rom[4] = 1'h0;
        my_rom[5] = 1'h1;
        my_rom[6] = 1'h0;
        my_rom[7] = 1'h0;
        my_rom[8] = 1'h0;
        my_rom[9] = 1'h0;
        my_rom[10] = 1'h1;
        my_rom[11] = 1'h0;
        my_rom[12] = 1'h1;
        my_rom[13] = 1'h0;
        my_rom[14] = 1'h0;
        my_rom[15] = 1'h0;
        my_rom[16] = 1'h0;
        my_rom[17] = 1'h0;
        my_rom[18] = 1'h0;
        my_rom[19] = 1'h0;
        my_rom[20] = 1'h0;
        my_rom[21] = 1'h0;
        my_rom[22] = 1'h0;
        my_rom[23] = 1'h0;
        my_rom[24] = 1'h0;
        my_rom[25] = 1'h0;
        my_rom[26] = 1'h0;
        my_rom[27] = 1'h1;
    end
endmodule

module DIG_ROM_32X1_y_1 (
    input [4:0] A,
    input sel,
    output reg [0:0] D
);
    reg [0:0] my_rom [0:20];

    always @ (*) begin
        if (~sel)
            D = 1'hz;
        else if (A > 5'h14)
            D = 1'h0;
        else
            D = my_rom[A];
    end

    initial begin
        my_rom[0] = 1'h0;
        my_rom[1] = 1'h1;
        my_rom[2] = 1'h0;
        my_rom[3] = 1'h0;
        my_rom[4] = 1'h0;
        my_rom[5] = 1'h1;
        my_rom[6] = 1'h0;
        my_rom[7] = 1'h0;
        my_rom[8] = 1'h0;
        my_rom[9] = 1'h0;
        my_rom[10] = 1'h0;
        my_rom[11] = 1'h0;
        my_rom[12] = 1'h0;
        my_rom[13] = 1'h0;
        my_rom[14] = 1'h0;
        my_rom[15] = 1'h0;
        my_rom[16] = 1'h0;
        my_rom[17] = 1'h1;
        my_rom[18] = 1'h0;
        my_rom[19] = 1'h0;
        my_rom[20] = 1'h1;
    end
endmodule

module DIG_ROM_32X1_y_0 (
    input [4:0] A,
    input sel,
    output reg [0:0] D
);
    reg [0:0] my_rom [0:20];

    always @ (*) begin
        if (~sel)
            D = 1'hz;
        else if (A > 5'h14)
            D = 1'h0;
        else
            D = my_rom[A];
    end

    initial begin
        my_rom[0] = 1'h0;
        my_rom[1] = 1'h0;
        my_rom[2] = 1'h0;
        my_rom[3] = 1'h0;
        my_rom[4] = 1'h0;
        my_rom[5] = 1'h0;
        my_rom[6] = 1'h0;
        my_rom[7] = 1'h0;
        my_rom[8] = 1'h1;
        my_rom[9] = 1'h1;
        my_rom[10] = 1'h1;
        my_rom[11] = 1'h0;
        my_rom[12] = 1'h1;
        my_rom[13] = 1'h1;
        my_rom[14] = 1'h1;
        my_rom[15] = 1'h0;
        my_rom[16] = 1'h0;
        my_rom[17] = 1'h0;
        my_rom[18] = 1'h1;
        my_rom[19] = 1'h0;
        my_rom[20] = 1'h1;
    end
endmodule

module DIG_D_FF_1bit
#(
    parameter Default = 0
)
(
   input D,
   input C,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule


module circuit (
  input x_1,
  input x_0,
  input CK,
  output z
);
  wire s0;
  wire y_2;
  wire s1;
  wire y_0;
  wire [4:0] s2;
  wire y_1;
  wire s3;
  assign s2[0] = y_0;
  assign s2[1] = y_1;
  assign s2[2] = y_2;
  assign s2[3] = x_0;
  assign s2[4] = x_1;
  // z
  DIG_ROM_32X1_z DIG_ROM_32X1_z_i0 (
    .A( s2 ),
    .sel( 1'b1 ),
    .D( z )
  );
  // y_2'
  DIG_ROM_32X1_y_2 DIG_ROM_32X1_y_2_i1 (
    .A( s2 ),
    .sel( 1'b1 ),
    .D( s0 )
  );
  // y_1'
  DIG_ROM_32X1_y_1 DIG_ROM_32X1_y_1_i2 (
    .A( s2 ),
    .sel( 1'b1 ),
    .D( s3 )
  );
  // y_0'
  DIG_ROM_32X1_y_0 DIG_ROM_32X1_y_0_i3 (
    .A( s2 ),
    .sel( 1'b1 ),
    .D( s1 )
  );
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i4 (
    .D( s0 ),
    .C( CK ),
    .Q( y_2 )
  );
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i5 (
    .D( s1 ),
    .C( CK ),
    .Q( y_0 )
  );
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i6 (
    .D( s3 ),
    .C( CK ),
    .Q( y_1 )
  );
endmodule
