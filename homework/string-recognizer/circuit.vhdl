-- generated by Digital. Don't modify this file!
-- Any changes will be lost if this file is regenerated.

LIBRARY ieee;
USE ieee.std_logic_1164.all;
use IEEE.NUMERIC_STD.ALL;

entity DIG_ROM_ROM is
  port (
    D: out std_logic_vector (3 downto 0);
    A: in std_logic_vector (4 downto 0);
    sel: in std_logic );
end DIG_ROM_ROM;

architecture Behavioral of DIG_ROM_ROM is
  type mem is array ( 0 to 19) of std_logic_vector (3 downto 0);
  constant my_Rom : mem := (
    "1000", "1000", "1100", "1000", "1010", "1000", "1100", "1000", "1000", 
    "1110", "1100", "0000", "1000", "1000", "1100", "0001", "1000", "1110", 
    "1100", "1000");
begin
  process (A, sel)
  begin
    if sel='0' then
      D <= (others => 'Z');
    elsif A > "10011" then
      D <= (others => '0');
    else
      D <= my_rom(to_integer(unsigned(A)));
    end if;
  end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DIG_D_FF is
  generic (
    Default: std_logic ); 
  port ( D  : in std_logic;
         C  : in std_logic;
         Q  : out std_logic;
         notQ : out std_logic );
end DIG_D_FF;

architecture Behavioral of DIG_D_FF is
   signal state : std_logic := Default;
begin
   Q    <= state;
   notQ <= NOT( state );

   process(C)
   begin
      if rising_edge(C) then
        state  <= D;
      end if;
   end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity main is
  port (
    x_1: in std_logic;
    x_0: in std_logic;
    CK: in std_logic;
    z: out std_logic);
end main;

architecture Behavioral of main is
  signal s0: std_logic_vector(4 downto 0);
  signal s1: std_logic_vector(3 downto 0);
  signal y_0: std_logic;
  signal y_1: std_logic;
  signal y_2: std_logic;
  signal s2: std_logic;
  signal s3: std_logic;
  signal s4: std_logic;
begin
  s0(0) <= x_1;
  s0(1) <= x_0;
  s0(2) <= y_0;
  s0(3) <= y_1;
  s0(4) <= y_2;
  gate0: entity work.DIG_ROM_ROM -- ROM
    port map (
      A => s0,
      sel => '1',
      D => s1);
  s2 <= s1(0);
  s4 <= s1(1);
  s3 <= s1(2);
  z <= s1(3);
  gate1: entity work.DIG_D_FF
    generic map (
      Default => '0')
    port map (
      D => s2,
      C => CK,
      Q => y_2);
  gate2: entity work.DIG_D_FF
    generic map (
      Default => '0')
    port map (
      D => s3,
      C => CK,
      Q => y_0);
  gate3: entity work.DIG_D_FF
    generic map (
      Default => '0')
    port map (
      D => s4,
      C => CK,
      Q => y_1);
end Behavioral;
