-- generated by Digital. Don't modify this file!
-- Any changes will be lost if this file is regenerated.

LIBRARY ieee;
USE ieee.std_logic_1164.all;
use IEEE.NUMERIC_STD.ALL;

entity DIG_ROM_z is
  port (
    D: out std_logic;
    A: in std_logic_vector (4 downto 0);
    sel: in std_logic );
end DIG_ROM_z;

architecture Behavioral of DIG_ROM_z is
  type mem is array ( 0 to 29) of std_logic;
  constant my_Rom : mem := (
    '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', 
    '0', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '0', '0', '1', '1'
    );
begin
  process (A, sel)
  begin
    if sel='0' then
      D <= 'Z';
    elsif A > "11101" then
      D <= '0';
    else
      D <= my_rom(to_integer(unsigned(A)));
    end if;
  end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
use IEEE.NUMERIC_STD.ALL;

entity DIG_ROM_y_2 is
  port (
    D: out std_logic;
    A: in std_logic_vector (4 downto 0);
    sel: in std_logic );
end DIG_ROM_y_2;

architecture Behavioral of DIG_ROM_y_2 is
  type mem is array ( 0 to 27) of std_logic;
  constant my_Rom : mem := (
    '0', '0', '0', '0', '0', '1', '0', '0', '0', '0', '1', '0', '1', '0', '0', 
    '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1');
begin
  process (A, sel)
  begin
    if sel='0' then
      D <= 'Z';
    elsif A > "11011" then
      D <= '0';
    else
      D <= my_rom(to_integer(unsigned(A)));
    end if;
  end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
use IEEE.NUMERIC_STD.ALL;

entity DIG_ROM_y_1 is
  port (
    D: out std_logic;
    A: in std_logic_vector (4 downto 0);
    sel: in std_logic );
end DIG_ROM_y_1;

architecture Behavioral of DIG_ROM_y_1 is
  type mem is array ( 0 to 20) of std_logic;
  constant my_Rom : mem := (
    '0', '1', '0', '0', '0', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', 
    '0', '0', '1', '0', '0', '1');
begin
  process (A, sel)
  begin
    if sel='0' then
      D <= 'Z';
    elsif A > "10100" then
      D <= '0';
    else
      D <= my_rom(to_integer(unsigned(A)));
    end if;
  end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
use IEEE.NUMERIC_STD.ALL;

entity DIG_ROM_y_0 is
  port (
    D: out std_logic;
    A: in std_logic_vector (4 downto 0);
    sel: in std_logic );
end DIG_ROM_y_0;

architecture Behavioral of DIG_ROM_y_0 is
  type mem is array ( 0 to 20) of std_logic;
  constant my_Rom : mem := (
    '0', '0', '0', '0', '0', '0', '0', '0', '1', '1', '1', '0', '1', '1', '1', 
    '0', '0', '0', '1', '0', '1');
begin
  process (A, sel)
  begin
    if sel='0' then
      D <= 'Z';
    elsif A > "10100" then
      D <= '0';
    else
      D <= my_rom(to_integer(unsigned(A)));
    end if;
  end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DIG_D_FF is
  generic (
    Default: std_logic ); 
  port ( D  : in std_logic;
         C  : in std_logic;
         Q  : out std_logic;
         notQ : out std_logic );
end DIG_D_FF;

architecture Behavioral of DIG_D_FF is
   signal state : std_logic := Default;
begin
   Q    <= state;
   notQ <= NOT( state );

   process(C)
   begin
      if rising_edge(C) then
        state  <= D;
      end if;
   end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity main is
  port (
    x_1: in std_logic;
    x_0: in std_logic;
    CK: in std_logic;
    z: out std_logic);
end main;

architecture Behavioral of main is
  signal s0: std_logic;
  signal y_2: std_logic;
  signal s1: std_logic;
  signal y_0: std_logic;
  signal s2: std_logic_vector(4 downto 0);
  signal y_1: std_logic;
  signal s3: std_logic;
begin
  s2(0) <= y_0;
  s2(1) <= y_1;
  s2(2) <= y_2;
  s2(3) <= x_0;
  s2(4) <= x_1;
  gate0: entity work.DIG_ROM_z -- z
    port map (
      A => s2,
      sel => '1',
      D => z);
  gate1: entity work.DIG_ROM_y_2 -- y_2'
    port map (
      A => s2,
      sel => '1',
      D => s0);
  gate2: entity work.DIG_ROM_y_1 -- y_1'
    port map (
      A => s2,
      sel => '1',
      D => s3);
  gate3: entity work.DIG_ROM_y_0 -- y_0'
    port map (
      A => s2,
      sel => '1',
      D => s1);
  gate4: entity work.DIG_D_FF
    generic map (
      Default => '0')
    port map (
      D => s0,
      C => CK,
      Q => y_2);
  gate5: entity work.DIG_D_FF
    generic map (
      Default => '0')
    port map (
      D => s1,
      C => CK,
      Q => y_0);
  gate6: entity work.DIG_D_FF
    generic map (
      Default => '0')
    port map (
      D => s3,
      C => CK,
      Q => y_1);
end Behavioral;
